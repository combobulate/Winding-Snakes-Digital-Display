## Winding Snakes Digital Display
 A visual of snakelike winding through a two-digit, 7-segment-per-digit display, for display while loading/processing.
 
 ![Gif of the display behavior](display.gif)

# Overview
This code uses logic and design from the VHDLWhiz "Hands-on for absolute beginners" fast-track course:
https://academy.vhdlwhiz.com/fast-track
This (highly recommended) course walks students through programming an FPGA to display a counter incrementing from 00 through 99 every second. The design and logic for the snakelike winding are my own contribution.

As I'm still very new to VHDL, my goals for this project were:
* Develop logic that uses different timing behavior from that used in the course. This was accomplished by experimenting to identify timing that made the snakelike winding appear fluid without being too fast, even though it is still clearly discrete still frames.
* Use logic which requires multiple sets of timing, where one is not an integer multiple of the other, as is found in the ones/tens digit logic of the counter developed in the course. This was accomplished by making each digit change at a slightly different rate using modulus logic.
* Identify areas for efficiency. This was accomplished by simplifying the encoding frame sequence from 34 sequential frames down to 14 distinct frames in the encoder process case statement, and by identifying smaller integer ranges for counters to minimize how much space was needed for each. In the course, a counter is used to count an entire second based on the clock speed of the FPGA board. Counting to 12,000,000 - 1 requires 24 bits. In my code, one counter is used to count to 30,000 - 1, 1/400th of a second on this board, requiring 15 bits. Another counter is used to count to 240 - 1, the least common multiple of the modulus values used (40 and 48) to set the update rates for each digit; this requires 8 bits. Combined, these counters require 23 bits. This 5/6 ratio of the modulus values such that one digit changes 10 times a second and the other 8 1/3 produced a performance that I liked better than other ratios and speeds. Achieving a lower number of bits for the desired performance doesn't appear possible based on this overall implementation; see below for some math about why that is. 
* Make the implementation as clean, simple, and clear as possible. Although generally a good practice, this is particularly specific to the case of implementing something based heavily on existing code; I wanted to avoid using existing code due to exhaustive copy and pasting unless it was actually needed.

# A Bit of Math
Is it possible to improve the counters further to take up less space on the board? Not without sacrificing the performance constraints of looking fluid and without a clearly faster-changing segment display. For example, we can reduce a bit from the clk-tied counter by counting half as high, to 1/800th of a second (15,000 clock cycles). This brings that counter from 15 down to 14 bits. This has the effect of making the counter for the modulus check (possible digit update opportunity) twice as frequent, so it requires doubling the modulus values to achieve the same display updates. Strictly doubling those to 80 and 96 gives a least common multiple is 480, requiring 9 bits and so losing the gained bit from changing the other counter. But we aren't tied to using exactly these numbers; we just want a similar range. For example, we could use 60 and 80 as our modulus values: these have a LCM of 240, only 8 bits. However, this 60/80 = 3/4 = 0.75 ratio is enough below the 40/48 = 5/6 = 0.83 ratio that I found it visibly clear which of the two digits was changing more slowly.

So, suppose a 3/4 ratio is the lowest bound, above which ratios of modulus values will produce similar enough speeds that the naked eye (well, my eye) doesn't notice that one of the digits is updating more slowly. Then to maintain an 8-bit number, we need two whole numbers greater than 48 (around twice, so say 150% to 250% greater) whose common multiple is below 256 and with a ratio greater than 3/4; one number times 4 and the other times 5 to form that common multiple, or one times 5 and the other times 6, etc. The 4/5 ratio will produce the largest values for our modulus, so consider the highest value below 256 which has both 4 and 5 as factors is 240. Dividing 240 by these factors produces 60 and 48. One of these is not greater than 48, and clearly taking the same approach with a 5/6 ratio will not produce two values greater than 48 either. So we can't keep our modulous check counter at 8 bits when we reduce the clk-tied counter to 14 bits. A similar approach of raising the clk-tied counter to 16 bits and instead looking for values around half of 40 and 48 finds that we can pull the modulous counter down to 7, but not down to 6: again, 23 bits is a limit. That number of bits is met with a 4/5 ratio as well as the 5/6 ratio, which is closer to 1 and so is used in this implementation.